\chapter{Hintergrund}\label{chap:background}
% \draft{Hintergrund Einführung}\\
% Es gibt bereits Methoden zur Erkennung von Concurrency-Bugs in
% Go Programmen, in denen Nachrichten zwischen Routinen ausgetauscht werden. 

% Im folgenden sollen zwei solche Methoden betrachtet und verglichen werden. 
% Dabei handelt es sich um ``Two-Phase Dynamic Analysis of Message-Passing Go
% Programs based on Vector Clocks'' von Sulzmann und Stadtmüller~\cite{PPDP18}
% und ``Who Goes First? Detecting Go Concurrency Bugs via Message Reordering'' 
% von Liu und Xia et al.~\cite{gfuzz}.

% \section{Two-Phase Dynamic Analysis of Message-Passing Go
% Programs based on Vector Clocks}\label{sec:PPDP18}
% \todo{Beschreibung von PPDP18}\\
% \extend{Beschreibung von PPDP18}\\
% Die Analyse von Sulzmann und Stadtmüller, im folgenden kurz als PPDP18 bezeichnet,
% nutzt ein zweiphasiges Model um Vector-Clock-Informationen zu erhalten auf 
% Basis welcher im Anschluss durch Trace-Replay nach möglichen Message Contentions,
% dem Senden zu einem geschlossenen Kanal, 
% Deadlock Recovery und alternativen 
% Kommunikationspartnern für Send/Receive Paare gesucht wird.

% \subsection{Tracing}\label{subsec:PPDP18Tracing}
% Mit dem Tracing wird der Ablauf eines Programmdurchlaufs aufgezeichnet. Aus 
% diesen Aufzeichnungen lassen sich im Anschluss die Vector-Clocks ableiten.
% Die Events werden dabei für jede Routinen einzeln aufgezeichnet. Für das 
% Senden und Empfangen über Channels werden jeweils ein Pre- und ein Postevent
% gespeichert.\\
% Im einzelnen werden die folgenden Events gespeichert:
% \begin{itemize}
%   \item $signal(i), wait(i)$ speichern das Erzeugen einer neuen Routinen.
%   \item $pre(x?), pre(x!)$ werden gespeichert, bevor Channel $x$ versucht eine Nachrichten zu erhalten oder zu senden.
%   \item $post(i, j, x?), pos(i, j, x!)$ werden gespeichert, wenn die Übertragung einer Nachricht über den Channel $x$ erfolgreich abgeschlossen 
%         worden ist. Dabei wird außerdem die ID des Kommunikationspartners $i$, sowie ein Zeitstempel $j$ der sendenden Routine aufgezeichnet.
%   \item $close(x)$ zeichnet auf, dass Channel $x$ geschlossen speichert.
%   \item $post(default)$ wird in dem Trace gespeichert, wenn der Default-Case in einem Switch-Statement ausgeführt wurde.
% \end{itemize}
% Man betrachte das folgende Beispielprogramm. Die Hauptroutine sei dabei Routine 1.
% Alle anderen Routinen sind mit ihrer ID versehen.
% \lstinputlisting{code/02-background/example_trace.txt}
% Der resultierende Trace gibt sich dabei zu 
% \begin{align*}
%   [&1\#[signal(2), signal(3), signal(4), signal(5)],\\
%    &2\#[wait(2), pre(x!), post(2, 1, x!)],\\
%    &3\#[wait(3), pre(x?), post(2, 1, x?), pre(x!), post(3, 2, x!)],\\
%    &4\#[wait(4), pre(y!), post(4, 1, y!), pre(x?), post(3, 2, x?)],\\
%    &5\#[wait(5), pre(y?), post(4, 1, y?)]]\\
% \end{align*}
