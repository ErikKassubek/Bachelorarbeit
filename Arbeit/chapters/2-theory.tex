\chapter{Theorie}\label{chap:background}
Im Folgenden sollen der theoretische Hintergrund bezüglich Nebenläufigkeit in Go
betrachtet werden. Außerdem werden die durch den Detektor betrachteten 
Probleme aufgezeigt.

\section{Routinen}\label{Chap:Back-Sec:Routine}
Bei Go-Routinen handelt es sich um leichtgewichtige Threads, welche 
nebenläufig mit anderen Routinen auf dem selben Adressraum laufen~\cite{effectiveGo}.
Anders als Threads in vielen anderen Programmiersprachen werden sie nicht 
durch den OS-Kernel, sondern durch die Go-Runtime selber gesteuert.
Diese besitzt einen eigenen Scheduler, welcher eine Technik namens $m$:$n$-Scheduling 
verwendet, um durch Multiplexing $m$ Go-Routinen auf $n$ OS-Threads auszuführen.
Diese Herangehensweise hat den Vorteil, dass dadurch eine bessere Ausführungsgeschwindigkeit 
erreicht und ein geringerer Speicher benötigt wird. Dadurch ist 
es möglich, dass tausende oder sogar hunderttausende Routinen gleichzeitig 
in einem Programm laufen. Sie erleichtert außerdem 
die Implementierung von Synchronisations- und Kommunikationsmechanismen.

\section{Mutexe}\label{Chap:Back-Sec:Mutex}
Mutexe (auch Locks genannt) gehören zu den am weitesten verbreitenten Mechanismen 
zur Synchronisierung nebenläufiger Programme~\cite{Undead}. Sie bilden 
eine Lösung für das Problem des kritischen Abschnitts. In solch einem 
kritischen Abschnitt darf sich immer nur maximal eine Routine gleichzeitig
aufhalten. Solche Abschnitte werden mit einem Mutex umschlossen. 
Sie werden unter anderem verwendet um zu verhindern, dass 
mehrere Routinen gleichzeitig auf die selbe globale Datenstruktur 
zugreifen. Mutexe besitzen zwei Zustände, geöffnet und geschlossen, mit denen 
ihre Verhalten gesteuert wird.
Sie besitzen dabei die folgenden Operationen:
\begin{itemize}
  \item Lock: Die Lock-Operation wird vor dem Eintritt in einen kritischen 
    Bereich aufgerufen. Sie versucht den Mutex zu schließen. Ist es momentan 
    geöffnet, wird der Mutex geschlossen und der kritische
    Bereich ausgeführt. Ist der Mutex bereits geschlossen, dann muss 
    die Routine, in welcher die Lock-Operation ausgeführt 
    werden soll so lange warten, bis der Mutex wieder geöffnet wird und 
    geschlossen werden kann.
  \item TryLock: Eine TryLock Operation versucht, wie die Lock-Operation,
    einen Mutex zu schließen. Anders als bei Lock wird die Routine allerdings 
    nicht blockiert, wenn eine Schließung nicht direkt möglich ist. Es wird 
    lediglich zurückgegeben, ob sie erfolgreich war oder nicht. Ein Programmierer 
    kann in diesem Fall selber entscheiden, wie das Programm weiter ablaufen 
    soll, ob also z.B. der kritische Bereich übersprungen werden soll.
  \item Unlock: Diese Operation öffnet einen geschlossenen Mutex. Der Versuch ein 
    geöffnetes Mutex zu öffnen führt zu einem Laufzeitfehler. 
    Theoretisch verhalten sich Mutexe in Go wie binäre Semaphore, d.h.~es ist möglich, 
    dass eine Routine ein 
    geschlossenes Mutex frei gibt, obwohl das Mutex von einer anderen Routine
    geschlossen wurde. Da dies in der Praxis sehr leicht zu einem 
    unvorhersehbaren Verhalten führen kann, ist es fast immer üblich, 
    ein Mutex immer nur von derjenigen Routine freizugeben, von der es beansprucht wurde. 
    Im weiteren wird daher angenommen, 
    dass ein Mutex immer von der Routine geöffnet wird, von welchem es 
    geschlossen wurde.
\end{itemize}
Mutexe können mit (Try)RLock Operationen zu RW-Mutex erweitert werden.
Dabei kann der selbe Mutex von mehreren 
(Try)RLock-Operationen geschlossen werden, ohne dass es zwischenzeitlich
geöffnet werden muss. Es ist allerdings 
nicht möglich, dass ein Mutex gleichzeitig über eine RLock- und eine Lock-Operation 
geschlossen wird. RW-Mutexe können z.B. verwendet werden, wenn mehrere Routinen 
gleichzeitig lesend auf eine Datenstruktur zugreifen dürfen, allerdings nur, 
wenn gerade keine Routine schreibend auf die selbe Datenstruktur zugreift.


\section{Channel}\label{Chap:Back-Sec:Chann}
Channel~\cite{effectiveGo} ermöglichen es Routinen untereinander zu 
kommunizieren.
Ein Channel \texttt{c} kann Daten \texttt{d} senden (\texttt{c} <- \texttt{d})
und empfangen (<- \texttt{c}). Das genaue Verhalten der Channel hängt dabei 
davon ab, ob es sich um einen gebufferten oder ungebufferten Channel handelt. \\
Bei einem ungebufferten Channel müssen Send- und Receive-Operation gleichzeitig 
ablaufen. Möchte eine Routine \texttt{R} Daten auf einem Channel \texttt{c} senden, 
ist aber keine Routine bereit die Daten von \texttt{c} zu empfangen, 
dann muss \texttt{R} so lange warten, bis eine andere Routine ein
Receive-Statement auf dem Channel \texttt{c} ausführt. Das selbe gilt auch, wenn 
eine Routine an ein Receive-Statement eines Channels kommt auf welchem 
momentan nicht gesendet wird.\\
Bei einem gebufferten Channel der Größe $n$ können bis zu $n$ Nachrichten
zwischengespeichert werden. Dies bedeutet, dass Send und Receive nicht mehr 
gleichzeitig ablaufen müssen. Eine Routine muss hierbei nur dann 
vor einer Operation warten, wenn eine Send-Operation auf einem vollen 
Channel, oder eine Receive-Operation auf einem leeren Channel ausgeführt 
wird. In allen anderen Fällen kann die Operation die Nachricht in den Buffer 
schreiben, bzw.~eine Nachricht aus dem Buffer lesen.\\
Basierend auf dem 
Go-Memory-Model gilt, dass zum einen das Senden auf einem Channel vor dem 
dazugehörigen Receive auf dem Channel synchronisiert wird und dass 
das $k$-te Receive auf einem Channel mit Kapazität $C$ vor der Beendigung
des $k+C$-ten Send auf dem Channel synchronisiert wird~\cite{memModel}.   
In der Praxis verhält sich der Buffer eines Channels allerdings wie eine FIFO-Queue,
das heißt, es wird bei einem Receive immer die ältest in dem
Buffer vorhandene Nachricht ausgegeben. Im Folgenden wird daher immer von diesem 
Verhalten ausgegangen.

Sowohl bei gebufferten als auch bei ungebufferten Channels kann es zu 
Situationen kommen, in denen mehrere Routinen gleichzeitig auf dem selben 
Channel auf eine Nachricht warten. Wird nun auf diesem Channel gesendet 
wird eine der Routinen pseudo-zufällig ausgewählt, um die Nachricht zu empfangen.

Go macht es mit der Select-Operation möglich, auf die erste von mehreren 
erfolgreichen Channel-Operationen gleichzeitig zu warten. Ein Beispiel für solch 
ein Select befindet sich in Abb.~\ref{Chan:Analyze-Sec:Channel-Fig:SelectEx}.
\begin{figure}[h!]
  \lstinputlisting{code/example_select.txt}
  \caption{Beispielprogramm für Select}
  \label{Chan:Analyze-Sec:Channel-Fig:SelectEx}
\end{figure}
In diesem Beispiel besitzt die Select-Operation 3 Cases und einen Default-Case.
Die Cases bestehen aus verschiedenen Channel-Operationen (Receive auf Channel, 
Receive auf Channel mit direkter Variablendeklaration und Send auf Channel).
Das Select-Statement probiert nun die Cases in einer zufälligen Reihenfolge 
aus. Findet es einen Case, in dem die Operation ausgeführt werden kann, wird 
die Operation, sowie der darunter stehende Block (Print-Statement) ausgeführt.
Der Default-Case wird ausgeführt, wenn keiner der anderen Cases ausgeführt 
werden kann. Er ist allerdings nicht notwendig. Besitzt das Select-Statement 
keinen Default-Case, dann blockiert die Routine so lange, bis einer der Cases 
ausgeführt werden kann.

Channel können vorzeitig durch eine \texttt{close} Operation geschlossen werden.
In diesem Fall kann auf diesem Channel nicht mehr gesendet werden. Versucht 
das Program auf einem geschlossenen Channel zu senden kommt es zu einem 
Laufzeitfehler und das Programm wird abgebrochen. Versucht das Programm 
auf einem geschlossenen Channel zu lesen, wir ein Default-Wert zurückgegeben,
ohne dass die Routine blockiert.

\section{Betrachtete Probleme}\label{chap:background-sec:Prob}
Dieser Abschnitt betrachtet die Arten von Problemen, welche durch den Detektor 
erkannt werden sollen. 

\subsection{Mutex}\label{Chap:Back-Sec:Prob-SubSec:Mutex}
Durch die Verwendung von Mutexen in nebenläufigen Programmen kann es 
zu sogenannten Deadlocks kommen. Blockieren sich dabei mehrere Routinen 
gegenseitig bezeichnen wir eine solche Situation als zyklisches Locking.
Abb.~\ref{Chap:Analyze-Sec:Mutex-Fig:Zyclic} zeigt ein Beispiel, in welchem es zu zyklischem 
Locking kommen kann.
\begin{figure}[h!]
  \lstinputlisting{code/zyclic-locking-example.txt}
  \caption{Beispielprogramm zyklisches Locking}
  \label{Chap:Analyze-Sec:Mutex-Fig:Zyclic}
\end{figure}
Routine 0 und Routine 1 können dabei gleichzeitig ausgeführt werden. Man betrachte den Fall, in dem 
Zeile 7 und 14 gleichzeitig ausgeführt werden, also Lock \texttt{y} von Routine 0 und Lock \texttt{x} 
von Routine 1 gehalten wird. In diesem Fall kann in keiner der Routinen die nächste Zeile ausgeführt werden,
da das jeweilige Locks, welches beansprucht werden soll bereits durch die andere Routine gehalten wird. 
Da sich diese Situation auch nicht von alleine auflösen kann, blockiert dass Programm, befindet sich also 
in einem zyklischen Deadlock.

Neben zyklischem Locking kann es auch durch doppeltes Locking von Mutexen 
zu Deadlocks kommen. Ein Beispiel dazu findet sich in 
Abb.~\ref{Chap:Analyze-Sec:Mutex-Fig:Double}.
\begin{figure}[h!]
  \lstinputlisting{code/double-locking-example.txt}
  \caption{Beispielprogramm doppeltes Locking}
  \label{Chap:Analyze-Sec:Mutex-Fig:Double}
\end{figure}
Der Mutex \texttt{x} soll hierbei mehrfach geschlossen werden, ohne dass 
es zwischenzeitlich geöffnet wird. In diesem Fall blockiert die Routine
endlos.


\subsection{Channel}\label{Chap:Back-Sec:Prob-SubSec:Channel}
Es kommt auf Channels dann zu Problemen, wenn es Send oder Receive-Operationen 
gibt, welche keinen gültigen Kommunikationspartner besitzen.
Der Detektor soll nun genau solche Programme erkennen, bei welchen es 
mögliche Ausführungspfade gibt, in denen solche Situationen auftreten können.
Man betrachte das Programm in Abb.~\ref{Chap:Analyze-Sec:Channel-SubSec:Dangling-Fig:ExDangling}.
\begin{figure}[h!]
  \lstinputlisting{code/example-dangling-channel.txt}
  \caption{Beispielprogramm mit hängendem Channel}
  \label{Chap:Analyze-Sec:Channel-SubSec:Dangling-Fig:ExDangling}
\end{figure}
Dieses besitzt zwei Receive aber nur eine Send-Operation. Unabhängig von der Ausführung 
gibt es also eine Receive-Operation, welche nie ausgeführt werden wird. 
Da ein Send oder Receive auf einem ungebufferten Channel, welche keinen 
Kommunikationspartner besitzt dazu führt, dass die entsprechende Routine 
ewig blockiert, führt dies somit zu einem Deadlock. 
Anders als in ungebufferten Kanälen müssen in gepufferten Kanälen Send und 
Receive einer Nachricht nicht gleichzeitig ablaufen. Hierbei kann es aber 
zu Situationen kommen, in dem eine Nachricht zwar erfolgreich gesendet, aber
nie ausgelesen wird oder auf einem Channel öfter gelesen als 
gesendet wird. Es führt also entweder zu einer nie gelesenen Nachricht 
oder, wenn ein Receive ewig vor einem leeren Channel wartet ebenfalls zu einem 
blockierenden Deadlock. Da es sich in diesen Fällen 
nahezu immer um ungewünschtes verhalten handelt sucht der Detektor nach 
Situationen, in denen so etwas auftreten kann.

Ein weiterer möglicher kritischer Fehler bei Channels liegt in dem 
Senden auf einem geschlossenen Channel. Man betrachte dazu das Beispiel in 
Abb.~\ref{Chap:Analyze-Sec:Channel-SubSec:Close-Fig:close}. 
\begin{figure}[h!]
  \lstinputlisting{code/example_send_to_closed.txt}
  \caption{Beispielprogramm für Senden auf geschlossenem Channel} 
  \label{Chap:Analyze-Sec:Channel-SubSec:Close-Fig:close}
\end{figure}
Das Programm 
versucht in Zeile 4 auf dem Channel \texttt{x} zu senden und in Zeile 
$\texttt{7}$ zu empfangen. In Zeile 10 wird \texttt{x} geschlossen. Da alle 
drei Operationen nebenläufig Ablaufen ist es möglich, dass der Channel 
geschlossen wird, bevor das Senden abgeschlossen wird.
Das Senden auf einem geschlossenen Channel führt dazu, dass das Programm 
abgebrochen wird. 
Das Empfangen auf einem geschlossen Channel ist hingegeben kein Problem.
Hierbei wird lediglich ein Default-Wert ausgegeben, ohne das die Operation
blockiert. 



