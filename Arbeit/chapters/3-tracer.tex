\chapter{Tracer}
Um ein Program analysieren zu können, wird der Ablauf eines Programmdurchlaufs
aufgezeichnet. Dazu wurde ein Tracer implementiert, durch welchem die 
Channel- und Lock-Operationen, sowie andere Operationen wie Select und das 
erzeugen einer neuen Routine, ersetzt, bzw. erweitert werden. Diese 
führen die eigentlichen Operationen aus und zeichnen gleichzeitig den 
Trace auf. Die Ersetzung durch die Drop-In Replacements kann dabei automatisch 
durch einen Instrumenter erfolgen, welche mit Hilfe des Abstract Syntax Tress 
die Ersetzungen vornimmt.\\
Anders als in vielen anderen Programmen, welche den Trace von Go-Programmen
analysieren, wie z.B.~\cite{GoAt2} oder~\cite{GoVis} wird dabei der Tracer 
selbst implementiert und basiert nicht auf dem Go-Runtime-Tracer~\cite{GoRunTrace}. 
Dies ermöglicht es, den Tracer genau auf die benötigten Informationen zuzuschneiden
und so einen geringeren negativen Einfluss auf die Laufzeit des Programms zu erreichen.

\extend{Tracer Einführung}

\section{Trace}
\draft{Trace} 
Der Aufbau des Trace basiert auf~\cite{PPDP18}. Er wird aber um Informationen 
über Locks erweitert. Der Trace wird für jede Routine
separat aufgezeichnet. Die Syntax des Traces in EBNF gibt sich 
folgendermaßen:
\begin{align*}
  \begin{matrix*}[l]
    T & = & ''\ [\ '',\ \{\ U\ \},\ ''\ ]\ ''; & \text{Trace}\\
    U & = & ''\ [\ '',\ \{\ t\ \},\ ''\ ]\ ''; & \text{lokaler Trace} \\
    t & = & signal(i)\ |\ wait(i)\ |\ pre(as)\ |\ post(i, j, a) & \text{Event}\\
      &   & |\ post(default)\ |\ close(x)\ |\ lock(y, b, c) & \\
      &   & |\ unlock(y); & \\
    a & = & x,\ (''\ !\ ''\ |\ ''\ ?\ ''); & \\
    as & = & a\ |\ (\{\ a\ \}, [\ ''\ default\ ''\ ]); & \\
    b & = & ''-''\ |\ ''t''\ |\ ''r''\ |\ ''tr'' & \\
    c & = & ''0''\ |\ ''1''
  \end{matrix*}
\end{align*}
wobei $i$ die Id einer Routine, $j$ einen Zeitstempel, $x$ die Id eines 
Channels und $y$ die Id eines Locks darstellt. Die Events haben dabei folgende Bedeutung:
\begin{itemize}
  \item \texttt{signal(i)}: In der momentanen Routine wurde eine Fork-Operation ausgeführt,
    d.h. eine neue Routine mit Id $i$ wurde erzeugt.
  \item \texttt{wait(i)}: Die momentane Routine mit Id $i$ wurde soeben erzeugt. Dies ist 
    in allen Routinen außer der Main-Routine das erste Event in ihrem lokalen Trace.
  \item \texttt{pre(as)}: Die Routine ist an einer Send- oder Receive-Operation eines 
    Channels oder an einem Select-Statement angekommen, dieses wurde aber noch nicht 
    ausgeführt. Das Argument $as$ gibt dabei die Richtung und den Channel an. 
    Ist $as = x!$, dann befindet sich der Trace vor einer Send-Operation, bei 
    $as = x?$ vor einer Receive-Operation. Bei einem Select-Statement ist 
    $as$ eine Liste aller Channels für die es einen 
    Case in dem Statement gibt. Besitzt das Statement einen Default-Case, wird
    dieser ebenfalls in diese List aufgenommen, also 
    $as = [\ x_1?, \ldots, x_n?, default]$.
  \item \texttt{post(i, j, a)}: Dieses Event wird in dem Trace gespeichert, nachdem 
    eine Send- oder Receive-Operation erfolgreich abgeschlossen wurde. 
    $i$ gibt dabei die Id und $j$ den momentanen Zeitstempel der sendenden Routine
    an. $a$ gibt wieder an, ob es sich um eine Send- ($a = x!$) oder Receive-Operation 
    ($a = x?$) auf dem Channel $x$ handelt. Durch die Speicherung der Id und des 
    Zeitstempels der sendenden Routine bei einer Receive-Operation lassen sich 
    die Send- und Receive-Operationen eindeutig zueinander Zuordnen.
  \item \texttt{post(default)}: Wird in einem Select-Statement der Default-Case ausgeführt,
    wird dies in dem Trace der entsprechenden Routine durch $post(default)$ 
    gespeichert.
  \item \texttt{close(x)}: Mit diesem Eintrag wird das schließen eines Channels $x$ 
    in dem Trace aufgezeichnet.
  \item \texttt{lock(y, b, c)}: Der Beanspruchungsversuch eines Locks mit Id j wurde beendet. 
    $b$ gibt dabei die Art der Beanspruchung an. Bei $b = r$ war es eine R-Lock
    Operation, bei $b = t$ eine Try-Lock Operation und bei $b = tr$ ein Try-R-Lock
    Operation. Bei einer normalen Lock-Operation ist $b = -$. Bei einer 
    Try-Lock Operation kann es passieren, dass die Operation beendet wird, 
    ohne das das Lock gehalten wird. In diesem Fall wird $c$ auf $0$, und 
    sonst auf $1$ gesetzt. 
\end{itemize}

Man betrachte als Beispiel das folgende Programm in Go:
\lstinputlisting{code/03-tracer/example_code_pre.txt}
Erweitert man diesen mit dem Tracer, erhält man folgendes Programm:
\lstinputlisting{code/03-tracer/example_code_post.txt}
Dieser ergibt den folgenden Trace:
\begin{align*}
  [&[signal(2),\ signal(3),\ signal(4),\ pre(3?, default),\ post(default)]\\
  &[wait(2),\ lock(1, -, 1),\ pre(1!),\ post(2, 2, 1!),\ unlock(1)]\\
  &[wait(3),\ pre(2!),\ post(3, 1, 2!),\ pre(1?),\ post(2, 2, 1?)]\\
  &[wait(4),\ pre(2?),\ post(3, 1, 2?)]]
\end{align*}
Aus diesem lässt sich der Ablauf des Programms
eindeutig nachverfolgen.
\extend{Tracer}


\section{Instrumenter}
\draft{Instrumenter}
Um den Trace zu erzeugen, müssen verschiedene Operationen durch Funktionen
des Tracers ersetzt bzw. erweitert werden. Wie man an dem Beispiel 
unschwer erkennen kann, besitzt die Version mit dem Tracer einen deutlich längeren
Programmcode, was bei der Implementierung zu einer größeren Arbeitslast 
führen kann. Da sich der Tracer auch negativ auf die Laufzeit des Programms 
auswirken kann, ist es in vielen Situationen nicht erwünscht, ihn in den 
eigentlichen Release-Code einzubauen, sondern eher in eine eigenständige 
Implementierung, welche nur für den Tracer verwendet werden. Um dies zu
automatisieren wurde ein zusätzliches Programm implementiert, welches in der 
Lage ist, den Tracer in normalen Go-Code einzufügen. Die Implementierung, 
welche ebenfalls in~\cite{GoChan} zur Verfügung steht, arbeitet mit einem 
Abstract Syntax Tree. Bei dem Durchlaufen dieses Baums werden die 
entsprechenden Operationen in dem Programm erkannt, und durch ihre entsprechenden 
Tracer-Funktionen ersetzt bzw.\ ergänzt. Neben dem Ersetzen der verschiedenen 
Operationen werden außerdem einige Funktionen hinzugefügt. Zu Begin der 
Main-Funktion des Programms wird der Tracer initialisiert. Zusätzlich
wird eine zusätzliche Go-Routine gestartet, in welcher ein Timer läuft. 
Ist dieser abgelaufen, wird der Trace ausgegeben \todo{(bzw. die Analyse gestartet)}, 
auch wenn das Programm noch nicht vollständig durchlaufen ist. Dies führt dazu,
dass auch Programme, in welchen ein Deadlock aufgetreten ist, analysiert 
werden können. 
\extend{Instrumenter}
