\chapter{Auswertung}\label{Chap:Eval}
Im Folgenden soll betrachtet werden, wie gut der beschriebene Detektor 
in der Lage ist, Situationen wie in Abschnitt~\ref{chap:background-sec:Prob}
beschrieben zu erkennen. Dabei werden sowohl künstlich konstruierte 
Situationen, als auch tatsächliche Programme betrachtet. Für die Betrachtung 
tatsächlicher Programme werden Programme aus Goker~\cite{gobench}
verwendet. Dieses besitzt eine Sammlung von Programmteilen mit 
Concurrency-Bugs aus 9 
großen open-source Anwendungen wie z.B. Kubernetes und Moby. 
Beschreibungen der Probleme, sowie die Ergebnisse des Detektors befinden in 
Anhang~\ref{Appendix-1}.

\section{Standardprobleme}
Für die Analyse wurden insgesamt 44 Standardprobleme betrachtet. 
Dabei handelt es sich um konstruierte Programme, welche bestimmte 
Situationen beinhalten, die durch den Detektor erkannt werden sollen, 
bzw. Situationen, welche mit einer problematischen Situation verwechselt 
werden könnten, ohne dass ein Problem auftreten kann.  
Dabei wurde überprüft, ob der Detektor in der Lage ist, das in dem 
Programm erhaltene Problem richtig zu erkennen, bzw.~zu erkennen wenn 
die vorliegende Situation nicht zu einem Problem führen kann. Eine 
tabellarische Beschreibung der betrachteten Situationen, sowie der Ergebnisse 
des Detektors ist in Tab.~\ref{App-Stand-Res} in Anhang~\ref{Appendix-1} aufgeführt.

Von den 44 Programmen konnten 41 korrekt kategorisiert werden. Dabei 
bestehen 18 Probleme aus Problemen mit Mutexen,
19 aus Problemen mit Channel und 7 mit einem 
Mix aus Mutexen und Channel. Abbildungen~\ref{Chap:Eval-Sec:Stand-Fig:Total}
bis~\ref{Chap:Eval-Sec:Stand-Fig:Mix} geben an, welcher Anteil der 
Betrachteten Standardprobleme korrekt erkannt wurde.

Für Programme, bei denen der Fehler auf die Verwendung von Mutexen 
basiert, konnten 17 der 18 Probleme richtig kategorisiert werden. 
Dies entspricht ca. $94.4\%$. 1 Problem bildet hierbei ein False-Negative.
Hierbei wird die Existenz eines potenziellen Deadlocks durch die 
Verschachtlung mehrere Routinen verschleiert.\\
Bei den Programmen, bei welchen es durch Channel zu Problemen kommen kann, 
lag der Detektor bei 18 der 19 Programme ($94.7\%$) richtig. Bei dem 
Programm, welches nicht korrekt erkannt wurde handelt es sich um ein False-Positive.\\
Bei Programmen, welche sowohl Mutexe als auch Channels verwenden liegt 
die Erfolgsquote bei 6  aus 7 ($85.7\%$). \\
Insgesamt hat der Detektor für die betrachteten Programme eine 
Trefferwahrscheinlichkeit von $93.2\%$. \\
Es sei noch dazu gesagt, dass die betrachteten Programme immer so implementiert 
worden sind, dass die entsprechenden Situationen auch in dem Durchlauf 
auftreten. Es ist allerdings auch möglich, dass Situationen bei den Durchläufen 
nicht durchlaufen werden, z.B. wenn sie sich ein einem konditionellen 
Block (If) befinden, bei welchem die Bedingung während keinem der Durchläufe 
wahr wird. Da die entsprechenden Operationen somit nicht aufgezeichnet 
werden können, ist es demnach logischerweise auch nicht möglich, dass der 
Detektor die entsprechenden Situationen erkennt.




\begin{minipage}{0.45\textwidth}
  \centering  
  \includegraphics[width=0.8\textwidth]{img/pi_standard_total.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Standardprogramme}
  \label{Chap:Eval-Sec:Stand-Fig:Total}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{img/pi_standard_mutex.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Standardprogramme mit Mutexen}
  \label{Chap:Eval-Sec:Stand-Fig:Mutex}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \centering  
  \includegraphics[width=0.8\textwidth]{img/pi_standard_channel.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Standardprogramme mit Channel}
  \label{Chap:Eval-Sec:Stand-Fig:Channel}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{img/pi_standard_mix.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Standardprogramme mit Mutexen und Channel}
  \label{Chap:Eval-Sec:Stand-Fig:Mix}
\end{minipage}

\section{GoKer}
Für die Analyse wurden insgesamt 34 Programme betrachtet. Die betrachteten 
Programme und deren Ergebnisse befinden sich in Tab.~\ref{App-Goker} 
in Anhang~\ref{Appendix-1}. Von den Programmen betrafen 15 die 
Verwendung von Resource wie Mutexen (14 korrekt erkannt), 11 die 
Verwendung von Kommunikationen (10 korrekt erkannt) und 8 eine Kombination aus Mutexen und 
Channel (7 korrekt erkannt). Da es sich hierbei nur um Situation handelt, welche 
tatsächlich Concurrency-Bugs enthalten ist eine Aufteilung nach FP und FN nicht 
möglich.
Die Erfolgsraten des Detektors für die Programme aus GoKer 
(Abb.~\ref{Chap:Eval-Sec:Goker-Fig:Total} bis~\ref{Chap:Eval-Sec:Goker-Fig:Mix})
stimmen dabei in etwa mit denen der Standardprogramme überein.
Für die Analyse wurden dabei nur solche Programme ausgewählt,
welche basieren auf ihrer Beschreibung für den Detektor theoretisch erkennbare 
Situation enthielt. Situationen, welche sich auf andere Concurrency-Bugs,
z.B. Race-Conditions bezogen, wurden nicht betrachtet. 
Die Betrachtung der Programme aus Goker hat einen Nachteil der hier 
verwendeten Methode, bzw. der Implementierung deutlich gemacht.
Der Instrumenter ist nur in der Lage den vorliegenden Code zu instrumentieren. 
Es kann aber vorkommen, dass in einem Programm externe Funktionen 
verwendet werden, welche Mutexe oder Channel als Parameter oder 
Rückgabewerte besitzen. Da bei der Instrumentierung Mutexe und Channel 
durch eingens implementierte Objekte ersetzt werden, externe Funktionen 
aber nicht entsprechend Instrumentiert werden können kommt es 
hierbei zu Compiler-Fehlern. Die entsprechenden Programme sind daher nicht 
lauffähig und können somit auch nicht analysiert werden. Programme aus GoKer, 
bei denen dies der Fall war wurden für die Analyse nicht betrachtet. 

\begin{minipage}{0.45\textwidth}
  \centering  
  \includegraphics[width=0.8\textwidth]{img/pi_goker_total.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Programme aus GoKer}
  \label{Chap:Eval-Sec:Goker-Fig:Total}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{img/pi_goker_mutex.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Programme aus GoKer mit Mutexen}
  \label{Chap:Eval-Sec:Goker-Fig:Mutex}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \centering  
  \includegraphics[width=0.8\textwidth]{img/pi_goker_channel.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Programme aus GoKer mit Channel}
  \label{Chap:Eval-Sec:Goker-Fig:Channel}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{img/pi_goker_mix.eps}
  \captionof{figure}{Verteilung der Ergebnisse für Programme aus GoKer mit Mutexen und Channel}
  \label{Chap:Eval-Sec:Goker-Fig:Mix}
\end{minipage}

\section{Vergleich zu anderen Detektoren}
Der Detektor vereinigt und erweitert Funktionsweisen aus verschiedenen 
Detektoren, und besitzt daher die Vorteile mehrerer Ansätze. Während sich 
einige Detektoren, wie z.B. UNDEAD~\cite{Undead} nur auf die Erkennung 
von Bugs, welche durch eine Art von Synchronisationsmechanismen ausgelöst werden 
spezialisiert, z.B. nur auf Mutexe,
vereinigt der entwickelte Detektor Methoden zur Erkennung von Problemen 
durch sowohl Mutexe als auch Channels. Er ist außerdem, anders als z.B. 
GFuzz~\cite{gfuzz} nicht nur in der Lage Situationen zu erkennen, welche 
bei dem betrachteten Durchlauf tatsächlich zu einem blockenden 
Deadlock führen, sondern ist auch in der Lage zu erkennen, wenn es in einem 
Programm durch eine andere Ausführungsordnung potenziell zu einem 
Bug kommen kann. Bei gebufferten Channels ist es hierbei auch in der Lage
Kommunikationen zu erkennen, welche zwar nicht zu einem blockenden 
Bug führen, welche aber dennoch keine vollständig ausgeführte Kommunikation 
bilden. 

\section{Probleme und Verbesserungsmöglichkeiten}
Der Detektor besitzt das selbe Problem wie alle dynamischen Ansätze. Er 
kann nur Probleme in den ausgeführten Programmteilen erkennen. Befinden sich 
tatsächlich oder potentielle Probleme teilweise oder vollständig in Bereichen, 
welche nicht ausgeführt wurden, z.B. auf Grund eines If-Statements, 
kann das entsprechende Problem nicht erkannt werden.

Das zweite größere Problem liegt in der Tatsache, dass die Kombination 
von Mutexen und Channels dazu führen kann, dass Bugs auftreten können
bzw.~dass Situationen, die bei der Betrachtung von nur Mutexen oder nur 
Channels zu Bugs führen könnten, welche durch die Kombination aber nicht auftreten 
können. Da Mutexe und Channel durch den Detektor getrennt voneinander betrachtet
werden, können demnach False-Positives oder False-Negatives entstehen. Durch eine andere 
Vereinigung der Methoden, bzw.~dem Betrachten der anderen Objekte in den 
Methoden wäre es prinzipiell möglich die Anzahl dieser Fehler zu reduzieren.

Als letztes geben sich außerdem Einschränkungen aus der Implementierung. 
Reine Go-Programme können einfach mit \texttt{go build} compiliert und anschließend 
das Executable direkt ausgeführt werden. Bei größeren Programmen ist dies 
häufig nicht direkt möglich. In diesen Fällen ist eine Anwendung des 
Detektors in seinem momentanen Stand nur sehr umständlich möglich. Ein anderes 
Problem besteht darin, dass importierte Libraries nicht instrumentiert werden.
Dies bedeutet, dass Library-Funktionen, welche Channels oder Mutexe als 
Parameter oder Rückgabewerte besitzen mit der momentanen Instrumentierung
zu Compiler-Fehlern führen. Um dies zu beheben wäre es möglich auch die 
entsprechenden Bibliotheken zu instrumentieren und diese dann einzubinden. 
Dies ist momentan allerdings noch nicht (automatisiert) möglich.