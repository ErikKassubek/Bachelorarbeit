\appendix
\chapter{Beschreibung der betrachteten Programme}\label{Appendix-1}
\begin{longtable}[h]{|l|c|}
  \hline
  \textbf{Beschreibung} & \textbf{Ok?} \\ \hline
  Potenzielles Deadlock durch zyklisches Locking von zwei Mutexen & Ja \\ \hline
  Potenzielles Deadlock durch zyklisches Locking von drei Locks & Ja \\ \hline
  \makecell[l]{Locking von zwei Locks, welche keinen Deadlock bilden, da Locking nicht\\zyklisch ist} & Ja \\ \hline
  \makecell[l]{Zyklisches Locking welches durch Gate-Locks nicht zu einem Deadlock\\führen kann} & Ja \\ \hline
  \makecell[l]{Potenzielles Deadlock, welches durch Verschachtlung mehrerer\\Routinen (fork/join) verschleiert wird} & Nein \\ \hline
  Deadlock durch doppeltes Locken & Ja \\ \hline
  Tatsächliches Deadlock durch zyklisches Locking von Locks in zwei Routinen & Ja \\ \hline
  Tatsächliches Deadlock durch zyklisches Locking von Locks in drei Routinen & Ja \\ \hline
  Doppeltes Locking mit TryLock (TryLock $\to$ Lock) & Ja \\ \hline
  Kein doppeltes Locking mit TryLock (Lock $\to$ TryLock) & Ja \\ \hline
  Deadlock durch zyklisches Locking mit TryLock & Ja \\ \hline
  Zyklisches Locking, welches durch TryLock nicht zu einem Deadlock führen kann & Ja \\ \hline   
  \makecell[l]{Potenzielles Deadlock mit RW-Mutexe in zwei Routinen} & Ja \\ \hline
  \makecell[l]{Kein potenzielles Deadlock mit RW-Mutexe in zwei Routinen} & Ja \\ \hline
  Kein potenzielles Deadlock, wegen Lock von RW-Locks als Gate-Locks & Ja \\ \hline
  Potenzielles Deadlock, da R-Lock von Deadlock nicht als Gate-Lock funktioniert & Ja\\ \hline
  \makecell[l]{Doppeltes Locking von RW-Locks, welches zu Deadlock führt\\(Lock$\to$Lock, RLock$\to$Lock, Lock$\to$Rlock)} & Ja \\ \hline
  \makecell[l]{Doppeltes Locking von RW-Locks, welches nicht zu einem\\Deadlock führt(RLock$\to$Rlock)} & Ja \\ \hline
  \makecell[l]{Deadlock oder hängende Routine durch Receive auf ungepuffertem Channel\\ohne Send} & Ja \\ \hline
  \makecell[l]{Deadlock oder hängende Routine durch Receive auf gepuffertem Channel\\ohne Send} & Ja \\ \hline
  \makecell[l]{Deadlock oder hängende Routiune durch 2-faches Receive mit 1-fachem Send\\$[$$R_0$: \{$\leftarrow$$x_1^0$\}, $R_1$: \{$x_1^0$$\leftarrow$1\}, $R_2$: \{$\leftarrow$$x_1^0$\}$]$} & Ja \\ \hline
  \makecell[l]{Deadlock oder hängende Routiune durch 2-faches Send mit 1-fachem Receive\\$[$$R_0$: \{$x_1^0$$\leftarrow$1\}, $R_1$: \{$x_1^0$$\leftarrow$1\}, $R_2$: \{$\leftarrow$$x_1^0$\}$]$} & Ja \\ \hline
  \makecell[l]{Deadlock oder hängende Routine durch Send auf ungepuffertem Channel\\ohne Receive} & Ja \\ \hline
  \makecell[l]{Kein Deadlock aber ungelesene Nachricht in Channel durch Send in \\Main-Routine auf gepuffertem Channel ohne Receive} & Ja \\ \hline
  \makecell[l]{Deadlock durch zweifaches Send auf gebufferten Channel in Kapazität 1\\in Main-Routine ohne Receive} & Ja \\ \hline
  \makecell[l]{Ungelesene Nachricht bei [$R_0$: \{$c_1^1$$\leftarrow$1; $c_1^1$$\leftarrow$1; $c_1^1$$\leftarrow$1\} , $R_1$: \{$\leftarrow$$c_1^1$\}, $R_2$: \{$\leftarrow$$c_1^1$\}]\\sowie Erkennung der
    potenziellen Kommunikationspartner} & Ja \\ \hline
  \makecell[l]{Keine Probleme bei [$R_0$: \{$c_1^1$$\leftarrow$1; $c_1^1$$\leftarrow$1\} , $R_1$: \{$\leftarrow$$c_1^1$\}, $R_2$: \{$\leftarrow$$c_1^1$\}]} & Ja \\ \hline
  \makecell[l]{Kein Kommunikationspartner wenn Receive in Fork bei ungebuffertem Channel\\$[$$R_0$: \{$c_1^0$ $\leftarrow$ 1; fork $R_1$\}, $R_1$: \{$\leftarrow$ $c_1^0$\}$]$} & Ja \\ \hline
  \makecell[l]{Mögliche Kommunikationspartner wenn Receive in Fork bei gebuffertem Channel\\$[$$R_0$: \{$c_1^1$ $\leftarrow$ 1; fork $R_1$\}, $R_1$: \{$\leftarrow$ $c_1^1$\}$]$} & Nein \\ \hline
  \makecell[l]{Deadlock bei Wahl eines bestimmten Select-Case\\$[$$R_0$: \{$\leftarrow$$c_3^0$\}, $R_1$: \{$c_1^0$ $\leftarrow$ 1\}, $R_2$: \{$c_2^0$ $\leftarrow$ 1\},\\$R_3$: \{select \{ case $\leftarrow$ $c_1^0$ $\Rightarrow$ \{$c_3^0$ $\leftarrow$ 1\}, case $\leftarrow$ $c_2^0$ $\Rightarrow$ \{$\leftarrow$ $c_3^0$\}\}\}$]$} & Ja \\ \hline
  \makecell[l]{Deadlock bei Wahl eines bestimmten Select-Case\\$[$$R_0$: \{$\leftarrow$$c_3^0$\}, $R_1$: \{$c_1^0$ $\leftarrow$ 1\}\\$R_2$: \{select \{ case $\leftarrow$ $c_1^0$ $\Rightarrow$ \{$c_3^0$ $\leftarrow$ 1\}; default $\Rightarrow$ \{$\leftarrow$ $c_3^0$\}\}\}$]$} & Ja \\ \hline
  Tatsächliches Send auf geschlossenen Channel & Ja \\ \hline
  Potenzielles aber nicht tatsächliches Send auf geschlossenen Channel Channel & Ja \\ \hline
  \makecell[l]{Kein Problem, wenn Channel erst nach letztem Send geschlossen werden\\kann [$R_0$: \{$c_1^0$ $\leftarrow$ 1; close($c_1^1$)\}, $R_1$: \{$\leftarrow$$c_1^1$\}]} & Ja \\ \hline
  \makecell[l]{Kein Problem, wenn Channel erst nach letztem Send geschlossen werden\\kann [$R_0$: \{$\leftarrow$$c_1^0$; close($c_1^1$)\}, $R_1$: \{$c_1^1$$\leftarrow$1\}]} & Nein \\ \hline
  \makecell[l]{Korrekte Kommunikationspartner bei [$R_0$: \{$c_1^1$ $\leftarrow$ 1; $c_1^1$ $\leftarrow$ 1; $c_1^1$ $\leftarrow$ 1\},\\$R_1$: \{$\leftarrow$$x$; $\leftarrow$$x$\}] (letztes Send hat keinen Kommunikationspartner)} & Ja \\ \hline
  \makecell[l]{Deadlock, da gleichzeitiges Send und Receive durch Mutex Lock verhindert\\wird [$R_0$: \{$m_1$.Lock; $\leftarrow$$c_1^0$; $m_1$.Unlock\}, $R_1$: \{$m_1$.Lock; $c_1^0$ $\leftarrow$ 1; $m_1$.Unlock\}]} & Ja \\ \hline
  \makecell[l]{Kein Problem, da gleichzeitiges Send und Receive durch RWMutex R-Lock nicht\\verhindert wird\\$[$$R_0$: \{$m_1^r$.RLock; $\leftarrow$$c_1^0$; $m_1^r$.RUnlock\}, $R_1$: \{$m_1^r$.RLock; $c_1^0$ $\leftarrow$ 1; $m_1^r$.RUnlock\}$]$} & Ja \\ \hline
  \makecell[l]{Kein potenzielles zyklisches Locking da Operationen durch Channel-Operation\\getrennt sind [$R_0$: \{$\leftarrow$$c_1^0$; $m_1$.Lock; $m_2$.Lock; $m_2$.Unock; $m_1$.Unlock;\},\\$R_1$: \{$m_2$.Lock; $m_1$.Lock; $m_1$.Unock; $m_2$.Unlock; $c_1^0$ $\leftarrow$ 1\}]} & Nein \\ \hline
  \makecell[l]{Tatsächlicher Deadlock, da Send durch Lock nicht erreicht werden kann\\$[$$R_0$: \{$m_1$.Lock; $c_1^0$$\leftarrow$1; $m_1$.Unlock\}, $R_1$: \{$m_1$.Lock; $\leftarrow$$c_1^0$; $m_1$.Unlock\}$]$} & Ja\\ \hline
  \makecell[l]{Potenzieller aber nicht tatsächlicher Deadlock ($R_1$ vor $R_2$), da Send durch Lock\\nicht erreicht werden könnte ($R_2$ vor $R_1$)\\$[$$R_0$: \{$m_1$.Lock; $c_1^0$$\leftarrow$1; $m_1$.Unlock\}, $R_1$: \{$m_1$.Lock; $\leftarrow$$c_1^0$; $m_1$.Unlock\}$]$} & Nein \\ \hline
  \makecell[l]{Potenzielles zyklisches Locking bei Wahl eines Select-Cases\\$[$$R_0$: \{$m_1$.Lock; $m_2$.Lock; $m_2$.Unlock; $m_1$.Unlock\},\\$R_1$: \{select \{case $\leftarrow c_1^0 \Rightarrow$ \{$m_2$.Lock; $m_1$.Lock; $m_1$.Unlock; $m_2$.Unlock\}, default $\Rightarrow$ \{\}\};\\$R_2$: \{$c_1^0$ <- 1\}\}$]$} & Ja \\ \hline
  \makecell[l]{Potenzielles zyklisches Locking bei Wahl eines DefaultSelect-Cases\\$[$$R_0$: \{$m_1$.Lock; $m_2$.Lock; $m_2$.Unlock; $m_1$.Unlock\},\\$R_1$: \{select \{case $\leftarrow c_1^0 \Rightarrow$ \{\}, default $\Rightarrow$ \{$m_2$.Lock; $m_1$.Lock; $m_1$.Unlock; $m_2$.Unlock\}\};\\$R_2$: \{$c_1^0$ <- 1\}\}$]$} & Ja \\ \hline
  \caption{Beschreibung der für die Auswertung betrachteten 
  Standardprogramme sowie 
  Information (Ok?) ob die Situation korrekt erkannt wurde. Ja bedeutet, dass 
  die Situation korrekt erkannt wurde
  und Nein, das das Problem nicht richtig kategorisiert wurde. In den Fällen in denen 
  Teile des Programmcodes angegeben sind sei $R_0$ die Main-Routine. $c_i^j$
  sei ein Channel mit Kapazität $j$, $m_i$ ein Mutex und $m_i^r$ ein RWMutex.}
  \label{App-Stand}
\end{longtable}